#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.3
# Kamailio as SIP Edge Router
# April 2020

# Need help?

# * Free/Official:
#	-	Documentation: https://www.kamailio.org/w/documentation/
#	-	Wiki: https://www.kamailio.org/wiki/
# 	-	Modules: https://www.kamailio.org/docs/modules/stable/
#	-	IRC: irc.freenode.net #kamailio
#	-	Mailing Lists: https://www.kamailio.org/w/mailing-lists/

# * Commercial:
#	-	LOD: https://lod.com fred@lod.com +1 (224) 334-3733
#	-	Business Directory: https://www.kamailio.org/w/business-directory/


####### Define Substitutions #######
# replace with values specific to your needs
#!substdef "/PRIVATEIP/192.1.1.1/"
#!substdef "/PUBLICIP/1.2.3.4/"
#!substdef "/PUBDOMAIN/mydomain.com/"
#### WE WANT TO USE TRUSTED INSTEAD
# The ip to set for forced socket
#!substdef "/SBCIP/1.2.3.5/"
#!substdef "/SBC2IP/1.2.3.6/"

####### Define Code Blocks #########
#	define WITH_DEBUG
#!define WITH_ANTIFLOOD
#	define WITH_SIPDEBUG

####### Global Parameters #########
### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5
pv_buffer_size=65536
pv_cache_limit=65536
log_facility=LOG_LOCAL0
log_prefix="{$mt $proto $hdr(CSeq) $ci} "
children=4
enable_tls=yes
disable_tls=no
disable_tcp=no
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605
dns=no
dns_cache_init=off
dns_srv_lb=no
dns_try_naptr=no
maxbuffer=65536
max_while_loops=250
rev_dns=no
use_dns_cache=no
auto_aliases=no
mhomed=0
listen=udp:PRIVATEIP:5060 advertise PUBLICIP:5060
listen=tcp:PRIVATEIP:5060 advertise PUBLICIP:5060
listen=tls:PRIVATEIP:4443
#listen=tls:PRIVATEIP:5061 advertise PUBLICIP:5061
alias=PRIVATEIP:5060
alias=PUBLICIP:5060
alias=PUBDOMAIN:5060
#alias=PRIVATEIP:4443
#alias=PUBLICIP:4443
#alias=PUBDOMAIN:4443
port=5060
#!ifdef WITH_SIPDEBUG
onsend_route_reply=yes
#!endif
server_header="Server: kamailio 5.3"

####### Modules Section ########
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "outbound.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "rtimer.so"
loadmodule "json.so"
loadmodule "http_client.so"
loadmodule "jansson.so"
loadmodule "htable.so"
loadmodule "textopsx.so"
loadmodule "rtpengine.so"
loadmodule "tls.so"
loadmodule "nathelper.so"
loadmodule "path.so"
loadmodule "websocket.so"
loadmodule "xhttp.so"
loadmodule "permissions.so"
loadmodule "ipops.so"
#avpops.so

#!ifdef WITH_ANTIFLOOD
loadmodule "pike.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif




# ----------------- setting module-specific parameters ---------------


# ----- permissions params -----
modparam("permissions", "default_allow_file", "/etc/kamailio/permissions.allow")


# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 1)
modparam("websocket", "ping_application_data", "Wake up")
modparam("websocket", "sub_protocols", 1)
# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

# ----- ctl params -----
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")
modparam("ctl", "binrpc", "tcp:localhost:2046")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "noisy_ctimer", 1)
modparam("tm", "cancel_b_method", 1)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)
modparam("rr", "ignore_sips", 1)
modparam("rr", "enable_double_rr", 2)

# ----- path -----
modparam("path", "enable_r2", 1)

# ----- rtimer params -----

# ----- tls params -----
modparam("tls", "ca_path", "/etc/letsencrypt/live/PUBDOMAIN/")
modparam("tls", "private_key", "/etc/letsencrypt/live/PUBDOMAIN/privkey.pem")
modparam("tls", "server_name", "PUBDOMAIN")
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "low_mem_threshold1", 0)
modparam("tls", "low_mem_threshold2", 0)

# ----- rtpproxy params -----
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")
modparam("rtpengine", "rtpengine_disable_tout", 15)
modparam("rtpengine", "rtpengine_tout_ms", 2000)
modparam("rtpengine", "rtpengine_retr", 2)

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=14400")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

# do not follow redirects
modparam("http_client", "httpredirect", 0)
modparam("http_client", "connection_timeout", 4)
modparam("http_client", "verify_peer", 0)
modparam("http_client", "verify_host", 0)
modparam("http_client", "keep_connections", 1)

####### Routing Logic ########
request_route {
#!ifdef WITH_SIPDEBUG
	xlog("L_INFO","[R-MAIN] SIP DEBUG: $mb\n");
#!endif

	# per request initial checks
	route(REQINIT);
	if (!is_method("INVITE")) {
	if ($si == "SBCIP" || $si == "SBC2IP") {
		xlog("L_INFO", "[MAIN] Message from SBC $rm\n");

		if ($od == "PUBLICIP") {
			xlog("L_INFO", "[MAIN] IS PUBLIC\n");
			$td = "PRIVATEIP";
			handle_ruri_alias();
			rtpengine_manage();
			remove_hf("Route");
			force_rport();
			$fs = "tls:PRIVATEIP:4443";
			route(RELAY);
			exit;
		}
	}
	}

	# CANCEL processing
	if (is_method("CANCEL")) {
		rtpengine_manage();
		handle_ruri_alias();

		if (!t_relay_cancel()) {
			xlog("L_INFO", "[MAIN] No matching transaction or other error on CANCEL\n");
			sl_send_reply("500", "Internal Server Error M1");
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if (t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);
        if (is_method("INVITE|SUBSCRIBE")){
                if ($rU == $null) {
                        sl_send_reply("484", "Address Incomplete");
                        exit;
                }
        }

	if ($si == "SBCIP" || $si == "SBC2IP") {
		if (!loose_route()) {
			switch($rc) {
			case -2:
				sl_send_reply("403", "Forbidden");
				exit;
			}
		}
		handle_ruri_alias();
		if (is_method("INVITE")) {
			xlog("L_INFO", "[R-MAIN] SBC INVITE calling RTPMANAGE\n");
			route(RTPMANAGE);
                }
		remove_hf("Route");
		force_rport();
		$fs = "tls:PRIVATEIP:4443";
	} else {
		if(proto != WSS) {
			xlog("L_INFO", "[R-MAIN] rejecting non tls $ru from $si\n");
			sl_send_reply("403", "Accepting TLS Only");
			exit;
		}

		if (is_method("REGISTER")) {
			remove_hf("Route");
			add_path();
			$du = "sip:SBCIP:5060";
		} else {
			if ($rU == $null) {
				sl_send_reply("484", "Address Incomplete");
				exit;
			}

			$ru = "sip:" + $rU + "@SBCIP:5060";
		}

		xlog("L_INFO", "[R-MAIN] BEFORE INSERTED CONTACT HEADER $ct\n");
		if ($(ct{tobody.user})!=$null) {
			xlog("L_INFO", "[R-MAIN] INSIDE INSERTED CONTACT HEADER $ct\n");
			$var(ctuser) = $(ct{tobody.user});
			$var(cthost) = $si;
			$var(ctport) = $sp;
			remove_hf("Contact");
			insert_hf("Contact: <sip:$var(ctuser)@PUBLICIP:5060;alias=$var(cthost)~$var(ctport)~5>\r\n", "Call-ID");
		}

		xlog("L_INFO", "[R-MAIN] HERE INSERTED CONTACT HEADER $ct\n");

		t_on_failure("MANAGE_FAILURE");
		$fs = "udp:PRIVATEIP:5060";
	}

	route(RELAY);
	exit;
}

# Wrapper for relaying requests
route[RELAY] {
	handle_ruri_alias();

	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if (!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}

	if (is_method("INVITE|SUBSCRIBE|UPDATE|REGISTER")) {
		if (!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}

	if (is_method("INVITE")) {
		if (!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	xlog("L_INFO", "[RELAY] Relaying $ru\n");
	if (!t_relay()) {
		sl_reply_error();
	}

	exit;
}

# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	# SBCIP mush change maybe use trusted.
	if (src_ip!=myself && $si != "SBCIP" && $si != "SBC2IP") {
		if ($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if ($sht(apiban=>$si)!=$null) {
			# ip is blocked from apiban.org
			xdbg("request from apiban.org blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xlog("L_ALERT","[R-REQINIT]: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif
	// WE have this in our ip[tables I think need to compare
	if ($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
		xlog("L_INFO","[R-REQINIT]: script kiddies from IP:$si:$sp - dropping and blocking\n");
		route(BLOCKIP);
		# sl_send_reply("200", "OK");
		exit;
	}

	// We can make sure this only matches a digit
	if ($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
		xlog("L_INFO","[R-REQINIT]: sql injection from IP:$si:$sp - dropping\n");
		route(BLOCKIP);
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		xlog("L_INFO","[R-REQINIT]: too many hops\n");
		sl_send_reply("483","R1 Too Many Hops");
		exit;
	}

	if (is_method("OPTIONS")){
		if (uri==myself && ($rU==$null || $rU=="kamailio")) {
			sl_send_reply("200","Keep on Keeping on");
			exit;
		}
	}

	if (!sanity_check("17895", "7")) {
		xlog("L_INFO","[R-REQINIT]: Malformed SIP message from $si:$sp\n");
		exit;
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;
	if ( is_method("BYE") ) {
	     xlog("L_INFO","[R-WITHINDLG]: BYE has_totag\n");
	}

	// If it has an alias route it
	if (($si == "SBCIP" || $si == "SBC2IP") && $(ru{param.value,alias})!=$null) {
		#handle_ruri_alias();
		xlog("L_INFO","[R-WITHINDLG]: TO TAG FROM SBCS $ru\n");
		route(RTPMANAGE);
		route(RELAY);
		exit;
	}

	if (loose_route()) {
		if ( is_method("BYE|ACK") ) {
		     xlog("L_INFO","[R-WITHINDLG]: $rm loose_routed\n");
		}
		if ( is_method("NOTIFY|ACK") ) {
		     xlog("L_INFO","[R-WITHINDLG]: $rm loose_routed recording_route\n");
			record_route();
		}
		#if (is_method("BYE")) {
		#     $du = "sip:SBCIP:5060";
		#}

		route(RTPMANAGE);
		route(RELAY);
		exit;
	}

	if ( is_method("ACK|BYE") ) {
		if ( is_method("BYE") ) {
		     xlog("L_INFO","[R-WITHINDLG]: BYE recording route\n");
			record_route();
		}
		route(RTPMANAGE);
		route(RELAY);
	}

	sl_send_reply("404","Not here WD1");
	exit;
}

# RTPProxy control and signaling updates for NAT traversal
route[RTPMANAGE] {
	if (has_totag()) {
		if (is_method("INVITE|UPDATE|ACK") || is_method("BYE")) {
			if (proto==WSS) {
				rtpengine_manage("trust-address replace-origin replace-session-connection ICE=remove RTP/AVP rtcp-mux-demux");
			} else {
				rtpengine_manage("trust-address replace-origin replace-session-connection ICE=force RTP/SAVPF rtcp-mux-offer DTLS=passive");
			}
		}
		t_on_reply("MANAGE_REPLY");
	} else {
		if (is_method("INVITE")) {
			if (has_body("application/sdp")) {
				if (proto==WSS) {
					rtpengine_manage("trust-address replace-origin replace-session-connection ICE=remove RTP/AVP rtcp-mux-demux");
				} else {
					xlog("L_INFO","[R-RTPMANAGE]: INVITE SBC $rm\n");
					rtpengine_manage("trust-address replace-origin replace-session-connection ICE=force RTP/SAVPF rtcp-mux-offer DTLS=passive SDES-off");
				}
			}
		}
	}
	return;
}

route[BLOCKIP] {
	if (src_ip!=myself) {
		xlog("L_INFO","[R-BLOCKIP:$ci]: blocking $rm from $fu (IP:$si:$sp)\n");
		$sht(ipban=>$si) = 1;
	}

	return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(RTPMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	if (($si != "SBCIP" && $si != "SBC2IP")) {
		if ($(ct{tobody.user})!=$null) {
			xlog("L_INFO","[R-M-REPLY] adding contact $ct $(ct{param.value,expires}) alias\n");
			$var(ctuser) = $(ct{tobody.user});
			$var(cthost) = $si;
			$var(ctport) = $sp;
			$var(ctexpires) = "";
			if ($(ct{param.in,expires}) == 1) {
				$var(ctexpires) = ";expires=" + $(ct{param.value,expires});
			}
			xlog("L_INFO","[R-M-REPLY] contact expires $var(ctexpires)\n");
			if (is_present_hf("Contact")) {
				remove_hf("Contact");
				insert_hf("Contact: <sip:$var(ctuser)@PUBLICIP:5060;alias=$var(cthost)~$var(ctport)~5>$var(ctexpires)\r\n","Call-ID");
			}
		}
	}

	if (!is_method("REGISTER")) {
		if (status=~"[12][0-9][0-9]") {
			route(RTPMANAGE);
		}
	}
}

# Manage failure routing cases
### Attempt othersbc ip?
failure_route[MANAGE_FAILURE] {
	xlog("L_INFO","[R-M-FAILURE] handling failure $rs\n");
	route(RTPMANAGE);
	if (t_is_canceled()) exit;
	if(t_is_expired()) {
	    xlog("L_INFO", "[R-DISPATCHER-ROLLOVER-FAIL:$ci] !> "
		"Transaction expired - aborting\n");
	    exit;
	}
#	if (t_branch_timeout()) {
#		t_relay_to_udp("SBC2IP", "5080")
#	}
}

#!ifdef WITH_SIPDEBUG
onsend_route {
	xlog("L_INFO","[ONSEND_ROUTE] SIP DEBUG: \n$snd(buf)\n");
}
#!endif

##### This is not used is it
route[NAT_WEBSOCKETS_CORRECT]
{
    # Do NAT traversal stuff for replies to a WebSocket connection
    # - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    xlog("L_INFO", "route natwebsockets correct");
    if (nat_uac_test(64)) {
        xlog("L_INFO", "$ci|log|this is a websocket request\n");
        add_contact_alias();
    }
}

##### This is not used is it
onreply_route[WS_REPLY] {
    xlog("L_INFO", "onreply wsroute");
        if (nat_uac_test("64")) {
                # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
                # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
                add_contact_alias();
        }
}

event_route[xhttp:request]
{
    xlog("L_INFO", "Web socket count: $sht(websockets=>$si::count)");
    set_reply_close();
    set_reply_no_connect();

    xlog("L_INFO", "event route \n");
    xlog("L_INFO", "$rm");
    xlog("L_INFO", "$hdr(Origin)");
    #xlog("L_INFO", "$fd\n");
    if(!is_ip_rfc1918($fd)) {
        if ($hu =~ "^/RPC") {
            xlog("L_INFO", "[xhttp:request] -> RPC\n");
            jsonrpc_dispatch();
        }
    }

    if (!($rm =~ "GET")) {
        xlog("L_INFO", "websocket|log|rejecting HTTP request $rm from $si:$sp\n");
        xhttp_reply("405", "Method Not Allowed", "", "");
        exit;
    }

    if (!($hdr(Connection) =~ "Upgrade")) {
        xlog("L_INFO", "websocket|log|rejecting HTTP connection $hdr(Connection) request from $si:$sp\n");
        xhttp_reply("400", "Bad Request", "", "");
        exit;
    }

    if (!($hdr(Upgrade) =~ "websocket")) {
        xlog("L_INFO", "websocket|log|rejecting HTTP upgrade $hdr(Upgrade) request from $si:$sp\n");
        xhttp_reply("400", "Bad Request", "", "");
        exit;
    }

    if (!($hdr(Sec-WebSocket-Protocol) =~ "sip")) {
        xlog("L_INFO", "websocket|log|rejecting request for websocket protocol $hdr(Sec-WebSocket-Protocol) from $si:$sp\n");
        xhttp_reply("400", "Bad Request", "", "");
        exit;
    }

    #!ifdef MY_WEBSOCKET_DOMAIN
    if (!($hdr(Origin) =~ "MY_WEBSOCKET_DOMAIN")) {
        xlog("L_INFO", "websocket|log|rejecting HTTP request with unknown origin $hdr(Origin) from $si:$sp\n");
        xhttp_reply("400", "Bad Request", "", "");
        exit;
    }
    #!endif

    ### each ip gets 50 connections?
    if($sht(websockets=>$si::count) > 50) {
        xlog("L_WARN", "websocket|log|$si:$sp is at the maximum allowable sockets per IP, rejecting request for another websocket\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    // Are we missing authentication here?
    // When will the websocket save to the location table?
    if (ws_handle_handshake()) {
        // Set an avp variable so we know to do a effemeral lookup???? // Transaction stuff???
        $var(shtinc) = $shtinc(websockets=>$si::count);
        xlog("L_INFO", "websocket|log|opened websocket $var(count) of 50 for $si:$sp\n");
        exit;
    }

    xlog("L_INFO", "websocket|log|unhandled HTTP request $rm from $si:$sp\n");
    xhttp_reply("404", "Not Found", "", "");
}

event_route[websocket:closed] {
    $var(shtdec) = $shtdec(websockets=>$si::count);
    if ($sht(websockets=>$si::count) < 1) {
        xlog("L_INFO", "websocket|log|$si:$sp closed last websocket to that IP\n");
        sht_rm_name_re("websockets=>$(si{re.subst,/\\./\\\\./g})::.*");
    } else {
        xlog("L_INFO", "websocket|log|closed websocket from $si:$sp, $var(count) remaining from that IP\n");
    }
}
